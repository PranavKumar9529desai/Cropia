---
/**
 * HeroParticles.astro
 * Canvas-based particle system with floating organic elements (seeds, leaves, pollen)
 * that create a gentle "living field" atmosphere for the hero section.
 */
---

<div class="hero-particles-container">
  <canvas id="hero-particles-canvas"></canvas>
</div>

<style>
  .hero-particles-container {
    position: absolute;
    inset: 0;
    pointer-events: none;
    z-index: 25;
    overflow: hidden;
  }

  #hero-particles-canvas {
    width: 100%;
    height: 100%;
    opacity: 0;
    transition: opacity 1.5s ease-in-out;
  }

  #hero-particles-canvas.loaded {
    opacity: 1;
  }
</style>

<script>
  class Particle {
    x: number;
    y: number;
    size: number;
    speedX: number;
    speedY: number;
    rotation: number;
    rotationSpeed: number;
    opacity: number;
    type: 'seed' | 'leaf' | 'pollen';
    color: string;
    canvas: HTMLCanvasElement;

    constructor(canvas: HTMLCanvasElement) {
      this.canvas = canvas;
      this.x = Math.random() * canvas.width;
      this.y = Math.random() * canvas.height;
      this.size = Math.random() * 8 + 4;
      this.speedX = (Math.random() - 0.5) * 0.5;
      this.speedY = -Math.random() * 0.8 - 0.2; // Floating upward
      this.rotation = Math.random() * Math.PI * 2;
      this.rotationSpeed = (Math.random() - 0.5) * 0.02;
      this.opacity = Math.random() * 0.5 + 0.3;
      
      // Random particle type
      const types: Array<'seed' | 'leaf' | 'pollen'> = ['seed', 'leaf', 'pollen'];
      this.type = types[Math.floor(Math.random() * types.length)];
      
      // Agricultural color palette (greens, yellows, soft browns)
      const colors = [
        'rgba(134, 239, 172, ', // Emerald-300
        'rgba(74, 222, 128, ',  // Green-400
        'rgba(253, 224, 71, ',  // Yellow-300
        'rgba(251, 191, 36, ',  // Amber-400
        'rgba(217, 249, 157, ', // Lime-200
      ];
      this.color = colors[Math.floor(Math.random() * colors.length)];
    }

    update(mouseX: number, mouseY: number) {
      // Base movement
      this.x += this.speedX;
      this.y += this.speedY;
      this.rotation += this.rotationSpeed;

      // Gentle wave motion
      this.x += Math.sin(this.y * 0.01) * 0.3;

      // Subtle mouse interaction (only on right half for desktop)
      if (this.canvas.width > 768) {
        const dx = mouseX - this.x;
        const dy = mouseY - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < 150) {
          this.x -= dx * 0.01;
          this.y -= dy * 0.01;
        }
      }

      // Reset particle when it goes off screen
      if (this.y < -20) {
        this.y = this.canvas.height + 20;
        this.x = Math.random() * this.canvas.width;
      }
      if (this.x < -20) this.x = this.canvas.width + 20;
      if (this.x > this.canvas.width + 20) this.x = -20;
    }

    draw(ctx: CanvasRenderingContext2D) {
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.rotation);
      ctx.globalAlpha = this.opacity;

      switch (this.type) {
        case 'seed':
          this.drawSeed(ctx);
          break;
        case 'leaf':
          this.drawLeaf(ctx);
          break;
        case 'pollen':
          this.drawPollen(ctx);
          break;
      }

      ctx.restore();
    }

    private drawSeed(ctx: CanvasRenderingContext2D) {
      // Elongated oval seed shape
      ctx.beginPath();
      ctx.ellipse(0, 0, this.size * 0.4, this.size, 0, 0, Math.PI * 2);
      ctx.fillStyle = this.color + this.opacity + ')';
      ctx.fill();
      
      // Small highlight
      ctx.beginPath();
      ctx.ellipse(-this.size * 0.15, -this.size * 0.3, this.size * 0.15, this.size * 0.3, 0, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity * 0.3})`;
      ctx.fill();
    }

    private drawLeaf(ctx: CanvasRenderingContext2D) {
      // Simple leaf shape
      ctx.beginPath();
      ctx.moveTo(0, -this.size);
      ctx.bezierCurveTo(
        this.size * 0.8, -this.size * 0.5,
        this.size * 0.8, this.size * 0.5,
        0, this.size
      );
      ctx.bezierCurveTo(
        -this.size * 0.8, this.size * 0.5,
        -this.size * 0.8, -this.size * 0.5,
        0, -this.size
      );
      ctx.fillStyle = this.color + this.opacity + ')';
      ctx.fill();

      // Center vein
      ctx.beginPath();
      ctx.moveTo(0, -this.size * 0.8);
      ctx.lineTo(0, this.size * 0.8);
      ctx.strokeStyle = `rgba(255, 255, 255, ${this.opacity * 0.4})`;
      ctx.lineWidth = 0.5;
      ctx.stroke();
    }

    private drawPollen(ctx: CanvasRenderingContext2D) {
      // Soft glowing circle
      const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
      gradient.addColorStop(0, this.color + this.opacity + ')');
      gradient.addColorStop(0.5, this.color + (this.opacity * 0.5) + ')');
      gradient.addColorStop(1, this.color + '0)');
      
      ctx.beginPath();
      ctx.arc(0, 0, this.size, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();
    }
  }

  class ParticleSystem {
    canvas: HTMLCanvasElement;
    ctx: CanvasRenderingContext2D;
    particles: Particle[];
    mouseX: number;
    mouseY: number;
    animationId: number | null;
    isVisible: boolean;

    constructor(canvasId: string) {
      this.canvas = document.getElementById(canvasId) as HTMLCanvasElement;
      this.ctx = this.canvas.getContext('2d')!;
      this.particles = [];
      this.mouseX = 0;
      this.mouseY = 0;
      this.animationId = null;
      this.isVisible = true;

      this.init();
    }

    init() {
      this.resize();
      this.createParticles();
      this.setupEventListeners();
      this.animate();
      
      // Fade in canvas after initialization
      setTimeout(() => {
        this.canvas.classList.add('loaded');
      }, 100);
    }

    resize() {
      const dpr = window.devicePixelRatio || 1;
      const rect = this.canvas.getBoundingClientRect();
      this.canvas.width = rect.width * dpr;
      this.canvas.height = rect.height * dpr;
      this.ctx.scale(dpr, dpr);
    }

    createParticles() {
      // Calculate particle count based on screen size
      const area = this.canvas.width * this.canvas.height;
      const baseCount = Math.min(Math.floor(area / 25000), 60);
      // Fewer particles on mobile
      const count = this.canvas.width < 768 ? Math.floor(baseCount * 0.5) : baseCount;

      this.particles = [];
      for (let i = 0; i < count; i++) {
        this.particles.push(new Particle(this.canvas));
      }
    }

    setupEventListeners() {
      // Throttled resize
      let resizeTimeout: number;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = window.setTimeout(() => {
          this.resize();
          this.createParticles();
        }, 250);
      });

      // Mouse tracking (for subtle interaction)
      document.addEventListener('mousemove', (e) => {
        const rect = this.canvas.getBoundingClientRect();
        this.mouseX = e.clientX - rect.left;
        this.mouseY = e.clientY - rect.top;
      });

      // Visibility API for performance
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          this.pause();
        } else {
          this.resume();
        }
      });

      // Intersection Observer for performance
      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            this.resume();
          } else {
            this.pause();
          }
        });
      }, { threshold: 0.1 });

      observer.observe(this.canvas);
    }

    animate() {
      if (!this.isVisible) return;

      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

      for (const particle of this.particles) {
        particle.update(this.mouseX, this.mouseY);
        particle.draw(this.ctx);
      }

      this.animationId = requestAnimationFrame(() => this.animate());
    }

    pause() {
      this.isVisible = false;
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
        this.animationId = null;
      }
    }

    resume() {
      if (!this.isVisible) {
        this.isVisible = true;
        this.animate();
      }
    }
  }

  // Initialize particle system when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    new ParticleSystem('hero-particles-canvas');
  });
</script>
