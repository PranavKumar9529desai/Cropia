generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "mongodb"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_DATABASE_URL")
}

model User {
  id            String         @id @map("_id")
  name          String
  email         String
  emailVerified Boolean        @default(false)
  image         String?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  sessions      Session[]
  accounts      Account[]
  location      Location?
  member        Member[]
  invitation    Invitation[]
  scans         Scan[]
  devices       Device[]
  notifications Notification[]

  @@unique([email])
  @@map("user")
}

model Session {
  id                   String        @id @map("_id")
  expiresAt            DateTime
  token                String
  createdAt            DateTime      @default(now())
  updatedAt            DateTime      @updatedAt
  ipAddress            String?
  userAgent            String?
  userId               String
  activeOrganizationId String?
  jurisdiction         Jurisdiction?
  user                 User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@index([userId])
  @@map("session")
}

model Account {
  id                    String    @id @map("_id")
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String   @id @map("_id")
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
  @@map("verification")
}

model Organization {
  id                String              @id @map("_id")
  name              String
  slug              String
  logo              String?
  createdAt         DateTime
  metadata          String?
  members           Member[]
  invitations       Invitation[]
  agentScanAnalyses AgentScanAnalysis[]
  scans             Scan[]

  @@unique([slug])
  @@map("organization")
}

model Member {
  id             String       @id @map("_id")
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  userId         String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  role           String       @default("admin") // e.g., "owner", "admin", "viewer"

  // --- JURISDICTION CONTROL ---
  // Stores the scope of this admin's power.
  // Structure: { state: "Maharashtra", district: "Kolhapur", taluka: "Hatkanangale" }
  // If a field is missing, they have no power at that level.
  // If a field is "*", they have full power.
  // each admin must have it s juridiction
  jurisdiction Jurisdiction?

  createdAt DateTime

  @@index([organizationId])
  @@index([userId])
  @@map("member")
}

type Jurisdiction {
  state    String // for state officer district and taluka should be "All"
  district String // for distrcit officer taluka should be "All"
  taluka   String // for taluka officer village should be "All"
  village  String // for village officer all the fild should correclty named like { state : maharashtra, district : kolhapur, taluka : hatkanangale, village : wathar}
}

model Invitation {
  id             String        @id @map("_id")
  organizationId String
  organization   Organization  @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  email          String
  role           String?
  status         String        @default("pending")
  expiresAt      DateTime
  createdAt      DateTime      @default(now())
  inviterId      String
  user           User          @relation(fields: [inviterId], references: [id], onDelete: Cascade)
  jurisdiction   Jurisdiction?

  @@index([organizationId])
  @@index([email])
  @@map("invitation")
}

model Location {
  id String @id @default(auto()) @map("_id") @db.ObjectId

  // Coordinates (From GPS)
  latitude  Float
  longitude Float

  // Address Details
  address String?

  // --- API VALIDATED FIELDS ---
  // These must match the India Location API values exactly
  state    String // e.g. "Maharashtra"
  district String // e.g. "Kolhapur"
  taluka   String? // e.g. "Hatkanangale" (Sub-District/Tehsil)
  village  String? // e.g. "Wathar"

  pincode String
  country String @default("India")

  // Relation to User
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Indexes for Geo-Spatial lookups (if needed later)
  @@index([state, district, taluka])
}

// Define the shape MongoDB expects for geospatial data
type ScanLocation {
  type        String  @default("Point")
  coordinates Float[] // IMPORTANT: MongoDB expects [Longitude, Latitude] order!
}

model Scan {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // 1. CLOUDINARY DATA
  imageUrl String
  publicId String

  // 2. AI METADATA 
  crop           String
  visualIssue    String?
  diagnosis      String?
  visualSeverity String? // e.g., "healthy", "warning", "critical"
  confidence     Float?

  // 3. LOCATION SNAPSHOT 
  // Copied from User.location at upload time.
  // WE MUST COPY ALL LEVELS to enable fast Admin Filtering.
  state     String? // <-- NEW: Allows "State Level" dashboards
  district  String?
  taluka    String? // <-- NEW: Allows "Taluka Level" dashboards
  village   String?
  pincode   String?
  latitude  Float?
  longitude Float?
  location  ScanLocation?
  // 4. RELATIONS
  userId    String
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  organizationId String?       @map("organizationId")
  organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  // 5. INDEXES (Powering "The Watchtower")
  @@index([userId])
  @@index([organizationId])
  // Dashboard Queries:
  // "Show me all scans in Maharashtra"
  @@index([state, createdAt])
  // "Show me all scans in Kolhapur"
  @@index([district, createdAt])
  // "Show me all scans in Hatkanangale"
  @@index([taluka, createdAt])
  @@index([location], map: "scan_geo_index") // The speed booster
  @@map("scan")
}

type AnalysisStats {
  // Data for the Donut Chart (e.g., { "Rust": 15, "Healthy": 40, "Leaf Spot": 5 })
  // Using Json here allows for a flexible map of issue names to counts
  diseaseDistribution Json

  // Basic metrics for the summary card
  totalScansAnalyzed Int
  avgConfidence      Float
}

model AgentScanAnalysis {
  id             String       @id @default(auto()) @map("_id") @db.ObjectId
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  // --- SCOPING ---
  // Matches the Admin's jurisdiction to ensure they only see analysis for their area
  state    String?
  district String?
  taluka   String?

  // --- AI RESULTS ---
  // Natural language headlines from Gemini (e.g., ["Rust cases up 40%", "New outbreak in Wathar"])
  headlines String[]

  // Structured JSON for charts (Donut, Bar, Temporal trends)
  // Store things like: { "diseaseDist": { "rust": 15, "healthy": 40 }, "topVillages": [...] }
  stats AnalysisStats?

  // --- CACHING & "RUN AGAIN" LOGIC ---
  // The total number of scans in this jurisdiction when the agent last ran
  lastScanCount Int

  // The ID or timestamp of the most recent scan processed
  // Used to quickly check if: currentScan.createdAt > analysis.lastProcessedAt
  lastProcessedAt DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([organizationId])
  @@index([state, district, taluka])
  @@map("agent_scan_analysis")
}

model Device {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  token     String   @unique
  platform  String? // android, ios, web
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@map("device")
}

type NotificationSource {
  name             String
  organizationName String?
  jurisdiction     String?
}

model Notification {
  id        String              @id @default(auto()) @map("_id") @db.ObjectId
  userId    String
  title     String
  body      String
  imageUrl  String?
  from      NotificationSource?
  seen      Boolean             @default(false)
  createdAt DateTime            @default(now())
  user      User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, seen])
  @@index([userId, createdAt])
  @@map("notification")
}
